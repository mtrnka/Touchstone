---
title: "Touchstone: CLMS re-scoring, classification, biological inference and more for Protein Prospector crosslink searches"
output: github_document
bibliography: tstone_readme.bib
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  cache = FALSE
)
```

## Protein Prospector - Touchstone CLMS pipeline

<!-- badges: start -->
<!-- badges: end -->

The Touchstone library exists to improve the functionality of [Protein Prospector](https://prospector.ucsf.edu/prospector/mshome.htm){target="_blank"} for Crosslinking
Mass Spectrometry [@trnka_matching_2014]. Touchstone re-scores Prospector CLMS 
results using an Support Vector Machine (SVM) classifier that does a better 
job discriminating between correct and incorrect crosslinks than the Prospector scores. 

It allows the user to classify datasets at a desired False Discovery Rate (FDR) 
threshold at various summarization levels: Crosslinked Spectral Matches (CSMs), 
Unique Residue Pairs (URPs), or Protein Pairs (PPs). Touchstone's FDR assessment
are highly consistent with error rates measured assessed by various benchmarking
datasets [@beveridge_synthetic_2020; @matzinger_mimicked_2022; @fischer_assessment_2025].

Additionally Touchstone contains features to help with dataset valdiation by 
measuring euclidean distances of crosslinks against high-res structure files, 
or by querying [STRING-db](https://string-db.org/){target="_blank"} for String Scores of 
putative protein interactions.

To aid with biological inference, Touchstone can optionally classify data into 
"Modules" which can designate either domains within a larger polypeptide 
or stable assemblies of multiple polypeptides (or both). There are convenience 
functions to export data to [XiNet](https://crosslinkviewer.org/){target="_blank"} and some 
internal plotting functions for quantitating CSMs across proteins or modules.

Touchstone is an R package that that I developed to address my own needs when 
analyzing CLMS datasets searched with Prospector, as a project scientist supporting 
numerous [projects](https://scholar.google.com/citations?hl=en&user=Gae1r_AAAAAJ&view_op=list_works&sortby=pubdate){target="_blank"} over the last decade or so. It is therefore a bit niche 
and wasn't developed with a wide user base in mind. Nor am I a software developer. 
So, it is rough around the edges. I am sharing it here because it might be 
helpful to some users, but if you are looking for a smooth user experience that 
doesn't require tinkering in R, you might be better served by other CLMS database 
search and re-scoring software.

I am currently only distributing a version here that is run in an R command line
environment, typically in [RStudio](https://posit.co/download/rstudio-desktop/){target="_blank"}. 
A demo version of a graphical interface (built in [Shiny](https://shiny.posit.co/){target="_blank"}) 
exists and is under development for eventual integration with Protein Prospector. 
This will be more accesible to a wider user-base. The eventual goal is to make 
Prospector CLMS searches more widely accessible to the research community.

The graphical demo version can be accessed at [shinyapps.io](https://prospts.shinyapps.io/tstoneapp/){target="_blank"}

Additional instructions for the graphical demo are [here](https://msf.ucsf.edu/mike/crosslinkingClass/dataset_summary.html){target="_blank"}

The rest of this mini-vignette will refer to running Touchstone inside of RStudio.

## Installation

The touchstone library is distributed on [GitHub](https://github.com/){target="_blank"}.
Install with:

```{r setup, results=FALSE, message=FALSE}
# install.packages("devtools")
devtools::install_github("mtrnka/Touchstone")

library(touchstone)
library(tidyverse)

```

## 80S Ribosome data acquired by MS2.HCD.

80S ribosome was produced using a rabbit reticulocyte cell free expression system. 
80S ribosomes were crosslinked with the cleavable reagent DSSO [@kao_development_2011].

This ribosomal system for method development and optimization of CLMS 
workflows. There is a high-res EM structure of the complex which can be helpful 
in determining if the crosslinked are assigned correctly or not, [pdb:6HCJ](https://www.rcsb.org/structure/6hcj){target="_blank"}.

![cryoEM structure of Rabbit 80S ribosome](https://cdn.rcsb.org/images/structures/6hcj_assembly-1.jpeg){width=30%}

The example dataset included with Touchstone is from 80S sample, split across 4
SEC fractions, each analyzed using a stepped-HCD MS2 acquisition cycle. Data were
searched for crosslinks using Protein Prospector program *Batch Tag*, against a 
protien database containing 77 ribosome sequences alongside a decoy database 
where each of the 77 target was randomized as well as 10x longer than the target 
sequences.

Touchstone expects unclassified search results with certain parameters included 
in the report. The recommended Search Compare Paramters are inlcuded as an example file:

```{r search_compare_params, results=FALSE}

# install.packages("jsonlite")
touchstone_example("tstoneMS2.4.json") %>% 
  jsonlite::read_json()

```

For CLMS of defined protein compleses with 2-200 subunits, I typically use a decoy
database that is either 5x or 10x larger than the target database. This does a better
job of modeling the distribution of incorrect hits. Touchstone has a parameter called 
the `decoy scaling factor` to adjust the math for this (it defaults to 1x). The 80S 
ribosome search usesa decoy databse in which each decoy protein is 10x longer than 
the corresponding target. If you don't use a value that matches the databse search
conditions everything will be wrong. Set the appropriate value for the scaling factor:

```{r scaling factor, messge=FALSE}

setDecoyScalingFactor(10)
```

After setting the decoy scaling factor (if needed), read the *Search Compare* output
into Touchstone:

```{r load_data, message=FALSE}
pathToDemoFile <- touchstone_example("rRibo_DSSO_sthcd_scOut.txt")
ribo.xl <- readProspectorXLOutput(pathToDemoFile, minPepLen = 4, minIons = 0)

```

The main Touchstone function is `trainCrosslinkScore()`. Running this will re-score
prospector CLMS results by building an SVM-score. `trainCrosslinkScore()` automatically
handles hyper-paramater optimization, feature selection, and data pre-filtering. It 
returns a list with CSMs and URPs along with score thresholds that will classify data
at the target error rates. Finally it returns some information about the features,
hyperparameter values, and prefilter values selected in the final model.


```{r tuning, messge=FALSE}
ribo.tune <- trainCrosslinkScore(ribo.xl, targetER = 0.01)

ribo.tune

ribo.csm <- ribo.tune$CSMs
ribo.csm.1 <- ribo.tune$CSM.thresh

# ribo.csm <- ribo.csm %>%
#   processModuleFile("inst/extdata/rRibo_newMod_uniprot.txt")
ribo.urp <- ribo.tune$URPs
ribo.urp.1 <- ribo.tune$URP.thresh

# ribo.ppi <- bestProtPair(ribo.csm)
# ribo.ppi.1 <- findSeparateThresholdsModelled(ribo.ppi, targetER = 0.01)

fdrPlots(ribo.urp, threshold=ribo.urp.1)
calculateFDR(ribo.urp, threshold=ribo.urp.1)

ribo.urp %>%
  countDecoys(threshold=ribo.urp.1) %>%
  flextable::flextable()

ribo.urp.sd.1 <- findSeparateThresholds(ribo.urp, targetER=0.01)

fdrPlots(ribo.urp, threshold=ribo.urp.sd.1, classifier="Score.Diff")
calculateFDR(ribo.urp, threshold=ribo.urp.sd.1)

ribo.urp %>%
  countDecoys(threshold = ribo.urp.sd.1, classifier="Score.Diff") %>%
  flextable::flextable()



# fdrPlots(ribo.urp, ribo.urp.1)
# calculateFDR(ribo.urp, ribo.urp.1)
# 
# fdrPlots(ribo2.urp, ribo2.urp.1)
# calculateFDR(ribo2.urp, ribo2.urp.1)
# 
# fdrPlots(ribo.urp.lin, ribo.urp.lin.1)
# calculateFDR(ribo.urp.lin, ribo.urp.lin.1)
# 
# ribo.urp %>%
#   classifyDataset(ribo.urp.1) %>%
#   countDecoys()
# 
# ribo2.urp %>%
#   classifyDataset(ribo2.urp.1) %>%
#   countDecoys()
# 
# ribo.urp.lin %>%
#   classifyDataset(ribo.urp.lin.1) %>%
#   countDecoys()
# 
# ribo.urp %>%
#   classifyDataset(ribo.urp.1) %>%
#   distancePlot2(threshold = 35)
# 
# fdrPlots(ribo.ppi, ribo.ppi.1)
# calculateFDR(ribo.ppi, ribo.ppi.1)
# 
# ribo.ppi %>%
#   classifyDataset(ribo.ppi.1) %>%
#   ggplot(aes(wtCSM)) +
#   geom_histogram(color="white") +
#   facet_grid(rows = vars(Decoy2), scales="free_y")
# 
# ribo.csm %>%
#   classifyDataset(ribo.ppi.1) %>%
#   calculatePairs() %>%
#   bestProtPair() %>%
#   ggplot(aes(wtCSM)) +
#   geom_histogram(color="white") +
#   facet_grid(rows = vars(Decoy2), scales="free_y")

```
The modulefile categorizes the 80 or so ribosomal proteins to either the large 
(60S) or small (40S) subunits and specified the mapping between the accession numbers
and the pdb file.



You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this.


In that case, don't forget to commit and push the resulting figure files, so they display on GitHub and CRAN.


## References:
